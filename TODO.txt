# Priorities

## Students

Heather 9/20
Atilla 9/25

Sophia 1/1
Ajay 1/1 
Anmay 1/1

Heather (advanced plots and case studies) -- chapter 1
Atilla (plots) -- chapter 2
Anmay -- chapter 3
Sophia (shaming) -- chapter 4
Ryan -- chapter 6
George -- chapter 7
Ajay -- rtweet (https://cran.r-project.org/web/packages/rtweet/)? tidytext (https://github.com/juliasilge/tidytext) (https://www.tidytextmining.com/) 

## Important topics for this summer

* Explore new render_book() improvements, Simplify the creation of the book. Make it a Github action upon pulling.

* Use the ggdistribution package, perhaps. https://t.co/8ue1b7Drh2?amp=1

* Should validity be moved to Wisdom? You need to establish valdity before you can presume to consider the Preceptor Table and the data to have come from the same population. Yes!

* Add rowSums() explanation to Chapter 2.

* Use rvar.

* Get rid of after_stat(). Or, if can't, then teach it properly and earlier.

* We need a "machine" which generates these predictions, which is the same thing as a machine which fills in all the question marks in the Actual Preceptor Table, which is the same thing as a machine which produces "fake data" which looks a lot like our actual data. This also leads directly to the concept of *posterior predictive checks*, which is just fancy terminology for helping to see if your model makes sense. If your model is reasonable, then you would expect to see Z (a feature of the real data) in either new data or in fake data generated by your model. If you see Z, then you should have more faith in your model. If you don't, then something is wrong.

* Get rid of 90% of the parameter interpretations discussions. Parameters, much less the posterior distributions of parameters, are not that interesting. We don't care with complex models, so we should not care (much) with simple models. Got a substantive question? Ask it directly as a newobs.

* Recall the two major hacks in our use of rstanarm. First, if there is only a constant in the model, we need to use `newdata = tibble(constant = 1)`. Better (and perhaps now available in development version) would be `newdata = tibble(.rows = 1)`, after showing students what `tibble(.rows = 1)` produces. Second, there `posterior_predict()` requires `as_tibble()` and `mutate_all(numeric)`. The first is OK. I don't object to explicitly changing matrices to tibbles. But the second is absurd, although necessary to deal with the columns being weird ppd class. This is also fixed in the dev version. With luck, we can get rid of these soon because a new version comes out. Requiring the installation of the dev version makes me nervous because of compilation issues.

* Related to the above is the latest version of the posteriors package and the new rvars data type. This looks like good stuff that will form the skeleton of Bayesian analysis going forward. But do we want to discuss this in the Primer? Maybe? Con is that it is too much. Just let students use tidybayes are some similar high level approach. Pro is that random variables are a key concept. The rvars allows you to do some fun stuff, stuff which reinforces the conceptual knowledge we want students to have. Also makes certain things, like manipulating draws to calculating causal effects much (?) easier.

* Maybe the best approach is to see to experiment a bit with the new version of tidybayes . . . Should also consider switching away from rstanarm and to brms, which seems more actively maintained. But I am very nervous that because "brms is based on Stan, a C++ compiler is required." But I really like the categorical() family in brms. Why doesn't rstanarm have something similar? It is in stan itself: https://mc-stan.org/docs/2_27/stan-users-guide/multi-logit-section.html. 

* https://github.com/stan-dev/rstanarm/issues/540

* At one point, I noticed that we got different answers in Chapter 6 between stan_glm() and creating the posterior by hand. I now think that this is a bug in rstanarm. See https://github.com/stan-dev/rstanarm/issues/509. Or maybe not! Looks like we use a bernoulli set up, so no problem?

* Add one or two other types of models. Maybe stan_gamm4(), for generalized additive models, or stan_polr(), for ordinal models. Or both? Idea is that the basic purpose of Justice is to choose a functional form. Given that, we ought to have a bunch of functional forms which we try. Sure wish that there were a stan_multilogit(), which would be an easy extention from logistic. (Maybe there is? I need to explore the different family arguments in stan_glm().) Something for time series might also be useful, given how common time series are in reality. Or maybe we can stick with stan_glm() and just use one of the other 6 or 7 family options. Maybe Gamma, which ensures that the outcome is positive. (Example: https://mc-stan.org/rstanarm/articles/continuous.html). Or poissson? Some of this might work well in chapter 8, since some of the left-hand side variables have few possible value and/or are always positive. multinomial/categorical regressions are available in the brms package. One way to still use rstanarm for this is discussed here: https://github.com/stan-dev/rstanarm/issues/20, trick is using Poisson count models.


* Keep in mind that the rvars package is coming along and will serve as the new foundation for the posterior package. This will change how we plot posteriors in the future, probably with a new version of tidybayes. Working with ggdist directly is not the best approach, I think.

* Discuss: Should "posterior probability distribution" become "ppd" or "PPD" everywhere?

## Other stuff

* Upgrade to new version of bookdown. And check out this book with R and Python mixed together. https://peopleanalytics-regression-book.org/. Also: https://bookdown.org/

* https://clauswilke.com/dataviz/

* Guide to the packages themselves, especially magic like Github Actions. Connect to this: https://www.rostrum.blog/2020/08/09/ghactions-pkgs/

* Consider this for entire document:
html_document:
    code_folding: "hide"




* Use chrome_print() to make PDF files instead of having to worry about tinytex and other arcana: https://rdrr.io/cran/pagedown/man/chrome_print.html

* When do we start using the new pipe? Whenever that is, we will want to update Getting Started to make the new pipe the default for CMD-shift-M. Presumably, there is a command for doing so. Discussion: https://blog.rstudio.com/2021/06/09/rstudio-v1-4-update-whats-new/


* Preceptor's Posterior is a posterior for which all the assumptions are true. Just because the big Data Science Machine has spat out a posterior does not mean that you should believe it blindly.

* Replace geom_histogram with ggdist throughout, although leave the first example and show how ggdist just makes everything easier.

* Look to this for motivation: https://mc-stan.org/rstanarm/articles/continuous.html

* Need to add fig.cap to any R code chunk for a figure which we want to reference. "If we assign a figure caption to a code chunk via the chunk option fig.cap, R plots will be put into figure environments, which will be automatically labeled and numbered, and can also be cross-referenced."

* Use ragg? ragg can be used when knitting Rmarkdown files by setting dev="ragg_png" in the code chunk options

https://www.tidyverse.org/blog/2021/02/modern-text-features/

* Add the notion of Preceptor's Posterior earlier.



* Stop spending time interpreting coefficients. Make fun of the practice. Instead, just ask a question and then answer it.

* $ git reset --soft HEAD~1

* The elipses should be vertical, not horizontal in all Preceptor Tables. fmt_markdown() would allow us to have vertical elipses in the Preceptor Tables.

* Discuss ps_2 to PS_2 problem on Github.

* Discuss relative paths and home directories more in Tools.

* Add grouping for line plots.

* Explaing age*gender versus age:gender distinction?

* Get rid of joins except left joins, and mention the others.

* Think about the difference between the *posterior distribution* of average height and the *posterior probability distribution*. Right now, we only use the latter. But the draws which are produced from epred() and predict() are really more examples of the former. Aren't they? That is, 4,000 height values is a *distribution*, as are all vectors, and it is *posterior* since we created it with a function that starts with "posterior". But nor is it a probability distribution since we have not normalized it yet. Shouldn't we weave this connection throughout the book.

* Should I use MAD_SD, MAD, mad or what? Should be consistent.

* Standardize use of "tidyverse". Only two choices: Either Tidyverse, when referring to the concept and/or to the collection of packages, or **tidyverse**, when referring to the package itself. Never use "tidyverse."

* Add ModernDive common problems isssues: https://moderndive.com/C-appendixC.html#data-wrangling

* https://leanpub.com/markua/

* https://education.rstudio.com/blog/2021/02/cbds/

* Start using "When comparing" everywhere.

* Fix tools to include discussion of Git for Windows and setting up the Terminal correctly: https://happygitwithr.com/shell.html#windows-shell-hell.

* Split maps into census and maps. Combine with ipums. Add code for making ipums graphics.

* Every model should feature a plot of predicted values and true outcomes. The decomposition is fine as far as it goes, but it is not the key image.

* Think harder about p() and Prob(). Which goes where?

* Use fitted() or predict() or both?

* Need testing in each chapter.

* Find/remove all usage of "controlling for x, we see". Use "adjust" instead.

* What do we think about the width of the code in the book? Sure seems like the comment lines go on for too long. Maybe? I don't like the way they care cut off in my Ipad, but . . . do many students read on Ipads?

* https://xkcd.com/2048/

* Show the secret weapon of doing the same regression many times and then gathering the results. nest_by(), perhaps.

* Better automated grading? https://ubc-dsci.github.io/rudaux

* Discuss the meaning of sigma more often. Really only need one sentence, but should give that sentence almost every time.

* Include links to disputes about governors work:

https://erikgahner.dk/2020/a-response-to-andrew-gelman/
https://statmodeling.stat.columbia.edu/2020/07/02/no-i-dont-believe-that-claim-based-on-regression-discontinuity-analysis-that/
https://github.com/jonspring/discontinuity/blob/master/fileb23c55435f90.gif

* Greek letters are for parameters which we can never observe. Latin letters are for observables.



* First, we can just print it. Chapter 7 walks the reader through all the parts of a stan_glm() model in detail. Later chapters will also show the printed model, but can move more quickly. Second, we create a summary table of the model using **gtsummary**. Note that this is just a different view of the same model. We don't show some things --- like sigma --- that we did show when just printing. We do show other things, like the 95% confidence interval which we did not show before. Neither is better! We use the one which is most helpful to our audience. Third, we use **tidybayes** to show histograms of the posterior distributions. The posterior is the underlying reality, the closest to the "truth" which we are going to get. The printed and table outputs are just summaries of the posterior. We might not show all three things every time, but we certainly always show the posterior. Graphics are pretty!

* After noting this formula, each example should create a plot with three histograms in a row --- left-to-right, the outcome (i.e., a histogram or density of Y), the fitted values (which is sometimes a spike, sometimes two spikes and so on) and, finally, the residuals. This highlights how we have *decomposed* the outcome into two parts: the model and the unmodeled variation. This belongs in the Courage chapter because it is a way of understanding the model we have made.



## To Discuss Later


* I like the hack of making your Rmd an index.Rmd and then the html will appear as a Github pages for free.


* Should use summary(fit_1) and discuss at some point. But when? Maybe Chapter 10?

* Do we need a cool graphics appendix, with  brief descriptions, pretty pictures from cool packages like: ggrepel, gghighlights, plotly. Others?



* More discussion of what it means to "control for" something in a regression. Right now, we don't mention this until chapter 11. Needs to be covered earlier, especially in chapter 9. That sets the stage for later.

* Standardize notation. What are predicted/fitted values? Use y_i everywhere, instead of using problem specific terms? That seems a bad (good?!) idea.

* Generate some error messages and then show that they can teach you something. Object does not exist. filter only have one equal sign, and so on. Do this all the time. Normalize the generation and processing of error messages.



*  Better workflow, automatic (with click confirmation) replacement of docs/ after successful check. Two parts: First, change the check so that it builds the book nicely. (Maybe not necessary. Maybe building the book in junk/ is OK?) Second, move the newly created book --- once it is accepted --- to docs/ on the master branch. Should we be taking multiple branches more seriously. Probably.
  + Things to discuss:
    - This change will prevent authors from easily knitting individual chapters. I will explore alternatives.
    - Two ways of handing auto-building and auot-updating:
      - 1) Create a new development branch. Students will submit PR to that branch. When you are ready, you can send a PR to merge to the master
           branch. The changes will only be live when you merge the development branch to the master branch.
      - 2) Keep things as they are. Once a student submits a PR, the build will directly go into docs/ and if successful, you can accept the PR
           and the new changes to the book will immediately be live. If the build check fails, do not accept the PR or else the deployment might
           break.


* Can you rebuild just a single chapter and then commit/push it? Right now, I have to rebuild the whole thing each time I want to make a single change. Takes too long.



# Appendices

Appendices have information that either a) a prof might reasonably decide not to assign or b) often contain material that students already know.

* Why Bayes?

* Messed up research articles. We need to prepare case studies of messed up articles. Start with those that Gelman cites. The tricky part is trying to figure out how to include these in class. And during which week do we use them.


* All the math you don't need to know. Bayes Theorem. Formulas. Normal distribution. Central limit theorem

* Advanced graphics, especially a tour of cool packages, including ggplotly and leaflet. gghighlight. ggstream.

* List of cool packages, googlesheet4 examples. : https://datavizm20.classes.andrewheiss.com/example/10-example/

* How to make an Rpubs and gists and saveWidgets:
https://datavizm20.classes.andrewheiss.com/example/10-example/

* Tufte and other graphics luminaries

* Leamer and other famous articles

* rtweet

* Making memes. Someone should figure out which meme maker is best for R. Or maybe we make our own. And then we make lots of memes for the book!


# From the Bookdown book

preview_chapter() and serve_book() as an aid to chapter writers.

webshot() tool for including images taken from webpages. Everytime we mention how cool source X is, we should provide a webshot of it. (And we should test that it exists.) Make the productivity chapter include way less of our prose.


p. 64 notes that adding the suffix 2 to various output formats gives you all the cool stuff, like figure captioning and numbering.

p. 74 has a useful discussion of configuration options for the _bookdown.yml file.

* rmd_subdir are subdirectories to search for source Rmd files. That seems critical for my submodule structure.

* output_dir is the output directory of the process (_book by default).

* clean is vector of files and directories to be cleaned by the clean_book() function.

pp. 5-6 discuss rmd_files as the way to define your own ordering for output files. This also goes in the _bookdown.yml file.


## Other links of interest:

https://r-charts.com/ (use these tutorials)
https://www.youtube.com/watch?v=CQS4xxz-2s4 (marginal and conditional distributions; quite hard; maybe optional?)


* Books

https://rstudio4edu.github.io/rstudio4edu-book/
https://ubc-dsci.github.io/introduction-to-datascience/
https://monika76five.github.io/ProbBayes/
https://bookdown.org/roback/bookdown-BeyondMLR/
https://dtkaplan.github.io/DataComputingEbook/

* Courses

https://ubc-dsci.github.io/dsci-100/
https://dataviz-2021.netlify.app/
https://jmbuhr.de/dataIntro20/
https://athanasiamo.github.io/tidyquintro/

* Other

https://evamaerey.github.io/flipbooks/about (use flipbooks for classroom exercises?)
https://nickch-k.github.io/EconometricsSlides/
https://holtzy.github.io/Pimp-my-rmd/

 https://fromthebottomoftheheap.net/2020/04/30/rendering-your-readme-with-github-actions/
 https://github.com/itsyaoyu/github_actions/blob/master/.github/workflows/main.yml
 https://www.willandskill.se/en/deleting-your-git-commit-history-without-removing-repo-on-github-bitbucket/

https://mdbeckman.github.io/JSM2020-Virtual/

* More cartoons like [xkcd](https://cran.r-project.org/package=RXKCD)

styler package

https://storywrangling.org/

https://desiree.rbind.io/post/2019/making-tip-boxes-with-bookdown-and-rmarkdown/ for making pretty boxes in the book

https://github.com/wikimedia/waxer for Wikipedia data

http://zevross.com/blog/2017/06/19/tips-and-tricks-for-working-with-images-and-figures-in-r-markdown-documents/

https://github.com/agmath/AppliedStatsInteractive

https://github.com/moodymudskipper/flow

https://github.com/ucbds-infra/ottr-sample

https://github.com/allisonhorst/stats-illustrations

https://bookdown.org/yihui/rmarkdown-cookbook/equatiomatic.html

Consider Netifly: https://cerebralmastication.com/2019/05/11/publishing-bookdown-to-netlify-automagically/

https://kieranhealy.org/categories/visualization/

https://openintro-ims.netlify.app/

https://education.rstudio.com/blog/2020/07/gtsummary/
https://moderndive.github.io/moderndive_labs/index.html
https://education.rstudio.com/blog/2020/07/learning-learnr/
https://rmarkdown.rstudio.com/authoring_shiny_prerendered.HTML

https://rstudio-education.github.io/tidyverse-cookbook/. I love this image: https://twitter.com/icymi_r/status/1407199200627113989/photo/1



* Look at the **flair** package to format the code. Or does that require us to have two copies of code: working copy and colored copy? https://education.rstudio.com/blog/2020/05/flair/

* Does using **flipbookr** make sense in the middle of a chapter?

* https://github.com/yonicd/carbonate -- perhaps useful for some nicer formatting of source code.


Take a look at drat.

https://community.rstudio.com/t/native-pipe-with-lm/110956 Pipe bend might be important. 

### Quotes to add:

https://blogs.bmj.com/bmj/2021/07/05/time-to-assume-that-health-research-is-fraudulent-until-proved-otherwise/ "It may be time to move from assuming that research has been honestly conducted and reported to assuming it to be untrustworthy until there is some evidence to the contrary." -- Richard Smith, editor of the BMJ for 13 years.

## Distribution/Probability material cut from the Primer

### Distribution Talk




### More distribution junk from Wrangling




### Working with draws

<!-- DK: Should I be working with tibbles instead of vectors? -->

Once we have a vector of draws, we can examine various aspects of the distribution. Examples:

```{r}
draws <- rnorm(100, mean = 2, sd = 1)
```

This is a case in which there is no distinction between the *true distribution* and the *estimated distribution*. We know, by assumption, what the truth is.

Even though we know, because we wrote the code, that the draws come from a normal distribution with a mean of 2 and a standard deviation of 1, the calculated results will not match those values exactly because the draws themselves are random. 

```{r}
mean(draws)
sd(draws)
```

Note that we are more likely to use the median and the mad to summarize a distribution. In this case, they are very similar to the mean and standard deviation.

```{r}
median(draws)
mad(draws)
```


In practice, we will not know the exact distribution which generates our data. (If we did know, then estimation would not be necessary.) The inherent randomness of the world means that calculated statistics will not match the underlying truth perfectly. But the more data that we collect, the closer the match will be.

In addition to the mean and standard deviation of the draws, we will often be interested in various quantiles of the distribution, most commonly because we want to create intervals which cover a specified portion of the draws. Examples:

```{r}
quantile(draws, probs = c(0.25, 0.75))
quantile(draws, probs = c(0.05, 0.95))
quantile(draws, probs = c(0.025, 0.975))
```

Note that these draws come from a distribution which is centered around 2 rather than 0. There is nothing intrinsically special about any of these ranges. They are mere convention, especially the 95% interval.

<!-- DK: Discuss confidence intervals. -->

Note how cavalier we are in sometimes using the word "distribution" and sometimes the word "draws." These are two different things! The distribution is the underlying reality, which we will only know for certain when we create it ourselves, as in this example. The draws are a vector of numbers which, we assume, are "drawn" from some underlying distribution which, in general, we do not know. 

By assumption, we can analyze the draws to make inferences about the distribution.

Although distributions (and the draws therefrom) are complex, we can often treat them in the same way that we treat simple numbers. For example, we can add two distributions together.

```{r}
n <- 100000
tibble(Normal = rnorm(n, mean = 1),
       Uniform = runif(n, min = 2, max = 3),
       Combined = Normal + Uniform) %>% 
  pivot_longer(cols = everything(),
               names_to = "Distribution",
               values_to = "draw") %>% 
  ggplot(aes(x = draw, fill = Distribution)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   alpha = 0.5, 
                   bins = 100, 
                   position = "identity") +
    labs(title = "Two Distributions and Their Sum",
         subtitle = "You can sum distributions just like you sum numbers",
         x = "Value",
         y = "Probability")
```

Drawing from a distribution also allows us to answer questions via *simulation.* For example, imagine that A and B are both flipping fair coins. A flips the coin 3 times. B flips the coin 6 times. What is the probability that A flips more heads than B?

It is obvious that B will win this game more often than A. It is also obvious that A will win some of the  time. But in order to estimate the chances of A winning, we can simply simulate playing the game 1,000 times.


```{r}
set.seed(56)
games <- 1000 

tibble(A_heads = rbinom(n = games, size = 3, prob = 0.5),
       B_heads = rbinom(n = games, size = 6, prob = 0.5)) %>% 
  mutate(A_wins = if_else(A_heads > B_heads, 1, 0)) %>% 
  summarize(A_chances = mean(A_wins))
```

A has about a 9% chance of winning the game.

In data science, the most important kind of distribution is a *probability distribution*, a concept which we will introduce in Chapter \@ref(probability).

<!-- DK: Could do more here, like look at prediction games, betting and so on. -->


This makes the *dual nature of distributions* more clear. A distribution is the "thing" you see in this plot. A mathematical object with several different parts, including a set of possible values (1 through 6, in this case) and a record of the number of times each value appears. A distribution is *also* the simple vector of numbers we used to create this plot.

In general, we travel back-and-forth between *distribution as a thing* and *distribution as a vector of draws* from the thing, depending on what we are trying to accomplish. 




